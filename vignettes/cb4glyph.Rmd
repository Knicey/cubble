---
title: "4. Making a glyph map"
output: rmarkdown::html_vignette
bibliography: '`r system.file("reference.bib", package = "cubble")`'
vignette: >
  %\VignetteIndexEntry{4. glyph}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE, 
  warning = FALSE,
  out.width = "100%"
)
```

```{r setup, echo = FALSE}
library(dplyr)
library(cubble)
library(ggplot2)
```

Sometimes, we wish to communicate spatial and temporal information collectively through visualisation. This can be achieved through several graphical displays: one can make faceted maps across time, creating map animations, or constructing interactive graphics to link between map and time series plot. While interactive graphics will be the main focus of vignette [6. Interactive graphics](cb6interactive.hml), this vignette will introduce a specific type of spatio-temporal plot called glyph maps.


# Understanding glyph maps

The concept of glyph maps was initially proposed in @Wickham2012-yr. The underlying idea is to transform the temporal coordinates into spatial coordinates so that time series plot can be displayed on the map. The diagram below illustrates how the coordinate transformation:

```{r echo = FALSE}
knitr::include_graphics("cluster-diagram/glyph-steps.png")
```

Subplot (1) show the spatial location of a weather station and subplot (2) displays its associated maximum temperature as time series in 2020. In subplot (3), the temporal coordinates are transformed into the spatial coordinates using linear algebra with a defined `height` and `width` (Equation 1 in @Wickham2012-yr), while the time series glyph remains unchanged. The transformed time series can then be plotted as a layer on the map in (4). 

The package `GGally` initially implement the glyph map. It uses `glyphs()` to calculate the axis transformation and then uses `geom_polygon()` to draw the map. In cubble, a ggproto implementation `geom_glyph()` performs the linear algebra internally as data transformation . The `geom_glyph()` requires four aesthetics: `x_major`, `y_major`, `x_minor`, and `y_minor`. The major axes are the outer spatial coordinates and the minor axes are the inner/ temporal coordinates: 

```
data |> 
  ggplot() +
  geom_glyph(aes(x_major = ..., x_minor = ..., y_major = ..., y_minor = ...))
```

Reference line and box can be added by separate geoms (`geom_glyph_box()`, `geom_glyph_line()`) with the same aesthetics (`x_major, x_minor, y_major, y_minor`). To avoid repetition, you may want specify the aesthetics collectively inside `ggplot()`:

```
data |> 
  ggplot(aes(x_major = ..., x_minor = ..., y_major = ..., y_minor = ...)) +
  geom_glyph_box() + 
  geom_glyph_line() + 
  geom_glyph()
```

If you want add an undelying map which does not use the four glyph map aesthetics, the argument `inherit.aes = FALSE` is handy: 

```
data |> 
  ggplot(aes(x_major = ..., x_minor = ..., y_major = ..., y_minor = ...)) +
  geom_sf(data = MAP_DATA, inherit.aes = FALSE)
  geom_glyph_box() + 
  geom_glyph_line() + 
  geom_glyph()
```
Taking the output from the [Get started](cubble.html) page, we can visualise the different in average temperature curve between 1971 - 1975 and 2016 - 2020 using the glyph map:

```{r echo = FALSE}
df <- climate_aus %>% 
  rowwise() %>% 
  filter(nrow(ts) == 366, id != "ASN00086127") %>% 
  filter(between(as.numeric(stringr::str_sub(id, 7, 8)), 76, 90)) %>% 
  face_temporal() %>% 
  group_by(month = lubridate::month(date)) %>%
  summarise(tmax = mean(tmax, na.rm = TRUE)) %>% 
  unfold(long, lat)
```

```{r}
vic_map <- ozmaps::abs_ste %>%  filter(NAME %in% c("Victoria"))
df %>% 
  ggplot(aes(x_major = long, y_major = lat, 
             x_minor = month, y_minor = tmax))  + 
  geom_sf(data = vic_map, 
          fill = "grey95", color = "white",
          inherit.aes = FALSE) + 
  geom_glyph_box(width = 0.3, height = 0.08) + 
  geom_glyph(width = 0.3, height = 0.08) + 
  scale_color_brewer(palette = "Dark2") + 
  coord_sf(xlim = c(141, 150)) + 
  theme_bw() + 
  theme(legend.position = "bottom") + 
  labs(x = "Longitude", y = "Latitude")
```

```{r eval = FALSE, echo = FALSE}
# script for diagram 
library(tidyverse)
library(ggsvg)
library(patchwork)
nsw <- ozmaps::abs_ste %>% 
  filter(NAME %in% c("New South Wales")) %>% 
  sf::st_simplify(dTolerance = 4000)

single <- climate_aus %>% filter(id == "ASN00076031")
glyph_dt <- single %>% face_temporal() %>% unfold(long, lat)
p1 <- ggplot() + 
  geom_sf(data = nsw,fill = "transparent", linetype = "dotted")+ 
  geom_point(data = single, aes(x = long, y = lat), color = "#443750") + 
  theme_bw() + 
  coord_sf(xlim = c(141, 143), ylim = c(-35, -33.5)) + 
  scale_x_continuous(breaks = seq(140, 143, 1)) + 
  scale_y_continuous(breaks = seq(-35, -33, 1)) + 
  ggtitle("(1)")

p2 <- single %>% 
  face_temporal() %>% 
  ggplot(aes(x = date, y = tmax)) + 
  geom_line(color = "#443750") + 
  theme_bw() + 
  theme() + 
  ggtitle("(2)")

glyph <- glyph_dt %>% 
  ggplot(aes(x_major = long, x_minor = as.numeric(date),
             y_major = lat, y_minor = tmax)) + 
  geom_glyph(width = 1, height = 0.3)

p3 <- layer_data(glyph) %>% 
  ggplot(aes(x = x, y = y)) + 
  geom_line(color = "#443750") +
  theme_bw() + 
  theme(axis.line = element_line(color = "#840032"),
        axis.text = element_text(color = "#840032", size = 10),
  ) + 
  ggtitle("(3)") + xlab("long") + ylab("lat")

p4 <- glyph_dt %>% 
  ggplot(aes(x_major = long, x_minor = as.numeric(date),
             y_major = lat, y_minor = tmax)) + 
  geom_sf(data = nsw, fill = "transparent", 
          linetype = "dotted", inherit.aes = FALSE) + 
  geom_glyph_box(width = 1, height = 0.3, color= "#840032", size = 1.2) + 
  geom_glyph(color = "#443750", width = 1, height = 0.3) + 
  geom_point(data = single, aes(x = long, y = lat), 
             color = "#443750", inherit.aes = FALSE) + 
  theme_bw() + 
  coord_sf(xlim = c(141, 143), ylim = c(-35, -33.5)) + 
  scale_x_continuous(breaks = seq(140, 143, 1)) + 
  scale_y_continuous(breaks = seq(-35, -33, 1)) + 
  ggtitle("(4)") + xlab("long") + ylab("lat")

g2 <- (p1 | p2) / (p4 | p3) + plot_layout(guides='collect') &
  theme(legend.position='none')

ggsave(g2, 
       filename = here::here("vignettes/cluster-diagram/glyph-steps.png"), 
       height = 4)
```


# Reference

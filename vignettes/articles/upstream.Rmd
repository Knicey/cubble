---
title: "0. Creating a cubble from data in the wild"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  cache = TRUE, 
  warning = FALSE,
  message = FALSE,
  eval = FALSE
)

library(cubble)
library(rnoaa)
library(tidyverse)
library(patchwork)
library(ggrepel)
library(absmapsdata)
library(sf)
```

This article shows you how to create a cubble from data in the wild through the example of query climate data from National Oceanic and Atmospheric Administration (NOAA) using the `rnoaa` package.

While there are many ways to query the data from NOAA, here I introduce a workflow using row-wise data frame, which makes it easy to turn into a cubble. This involves first create a row-wise tibble with one row per station, and then query the climate data as a nested list for each station.

Suppose we want to find a few climate stations close to Melbourne and Sydney, `rnoaa` has a function `meteo_nearby_stations()` for this task, given the coordinates of the locations. Here we create `lat_long_df` that contains the coordinates of the two cities. We also create a station data, `all_stations`, that includes all the Australia stations with a WMO ID and have records in 2020. This reduce the searching range from stations all over the global to only Australian stations and records from WMO stations tend to have better quality control. We set `limit = 5` to query 5 closest stations of each city. After some cleaning, this is what we've got:

```{r}
lat_lon_df <- data.frame(id = c("sydney", "melbourne"),
                         latitude = c(-33.8675, -37.8136),
                         longitude = c(151.2070, 144.9631))

all_stations <- ghcnd_stations() %>%
  filter(str_detect(id, "ASN"),
         first_year < 2020,
         last_year > 2019) %>%
  mutate(wmo_id = as.numeric(wmo_id)) %>%
  filter(!is.na(wmo_id))

nearby_stations <-  meteo_nearby_stations(lat_lon_df = lat_lon_df,
                                          station_data = all_stations, 
                                          limit = 5)

stations <- bind_rows(nearby_stations$melbourne %>% mutate(city = "melbourne"),
                      nearby_stations$sydney %>% mutate(city = "sydney"))

stations
```

With these 10 stations, we want to make sure they all have precipitation (`PRCP`), maximum temperature (`TMAX`), and minimum temperature (`TMIN`) recorded. `ncdc_datatypes()` allows us to query the variables recorded for each station. We use `rowwise()` to formulate the tibble as a row-wise data frame and append a list column, `var`, that shows the variables recorded for each station. The three variables `PRCP`, `TMAX`, and `TMIN` are then detected to filter for the stations:

```{r}
station_selected <- stations %>% 
  rowwise() %>% 
  mutate(var = list(ncdc_datatypes(datasetid = "GHCND", 
                                   stationid = paste0("GHCND:", id))$data)) %>% 
  mutate(prcp = any(str_detect(var$id, "PRCP")),
         tmax = any(str_detect(var$id, "TMAX")),
         tmin = any(str_detect(var$id, "TMIN"))) %>% 
  filter(prcp, tmax, tmin) %>% 
  select(-c(var:tmin))

station_selected
```

After the filter, we can see that one of the Sydney stations, `SYDNEY HARBOUR`, is removed. A further investigation shows that it doesn't record precipitation.  

Lastly, we can grab the climate data with `meteo_pull_monitors()` and again, with the row-wise data frame structure, we can append all the climate information into a list-column without expanding the time dimension. To make it quick-and-dirty, we only query the results in January 2020.

```{r}
sydmel_climate <- station_selected %>% 
  mutate(ts = list(meteo_pull_monitors(id, 
                                       date_min = "2020-01-01", 
                                       date_max = "2020-01-31",
                                       var = c("PRCP", "TMAX", "TMIN"))))

sydmel_climate
```

If you have followed along, the output you have should be a row-wise data frame with all the climate time series data nested into a column called `ts`. This data can be directly turned into a cubble with `tamp` with a supply of the grouping variable, `id`:

```{r}
sydmel_climate %>% tamp(id)
```

Here you go! Let's look at these stations on the map:

```{r fig.width=10, fig.height=5, echo = FALSE}
out <- sydmel_climate %>% tamp(id)
state_map <- sa42016 %>% dplyr::filter(gcc_name_2016 %in% c("Greater Melbourne", "Greater Sydney")) 

p1 <-  plot_map(state_map %>% filter(gcc_name_2016 == "Greater Sydney")) +
  geom_label_repel(data = out %>% filter(city == "sydney"), 
                   aes(x = longitude, y = latitude, label = name), 
                   max.iter = 1e7, min.segment.length = 0.01, box.padding = 0.5) + 
  geom_point(data = out %>% filter(city == "sydney"), 
             aes(x = longitude, y = latitude)) + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) + 
  ggtitle("Sydney")

p2 <- plot_map(state_map %>% filter(gcc_name_2016 == "Greater Melbourne")) +
  geom_label_repel(data = out %>% filter(city == "melbourne"), 
                   aes(x = longitude, y = latitude, label = name), 
                   max.iter = 1e7, min.segment.length = 0.1) + 
  geom_point(data = out %>% filter(city == "melbourne"), 
             aes(x = longitude, y = latitude)) + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) + 
  ggtitle("Melbourne")

p1 | p2
```


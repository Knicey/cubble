---
title: "3. Application: Matching nearby stations"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE,
  message = FALSE,
  out.width = "100%"
)
library(cubble)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(sf)
library(patchwork)
```

One common type of task with spatio-temporal data is to match nearby sites. For example, we may want to verify the location of an old list of stations with current stations, or we may want to pair the automated weater station with the closest traditional station to calibrate records, or we may want to investigate whether the rainfall will get translated to the river level. Some of these matches only concern the spatial dimension, while others, i.e. matching rainfall and river level, also require the temporal agreement.

This vignette introduces how to spatially and spatio-temporally match between sites with the cubble structure with two examples. The first example pairs traditional weather stations with nearby automated stations in New South Wales, Australia. This exercise only concerns the matching based on spherical distance between stations. The next example pairs the river level recorded by the river gauges with the precipitation recorded by the nearby weather station in Victoria, Australia. 

# Example 1

In `weatherdata::climate_full`, New South Wales automated stations are suffixed with `aws` in its name. This information tells us the automated stations from the traditional one: 

```{r}
nsw_map <- ozmaps::abs_ste %>% filter(NAME == "New South Wales")  

nsw <- weatherdata::climate_full %>%   
  filter(between(stringr::str_sub(id, 7, 8), 46, 75)) %>%
  mutate(automated = str_detect(name, "aws")) %>% 
  stretch(ts) %>%
  filter(lubridate::month(date) == 1,
         lubridate::year(date) == 2020) %>% 
  tamp() %>% 
  filter(!any(is.na(ts$tmax)))
 

plot_map(nsw_map) +
  geom_point(data = nsw, 
             aes(x = long, y = lat, color = automated)) + 
  scale_color_brewer(palette = "Dark2") + 
  ggtitle("New Sourth Wales") + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
   coord_sf(xlim = c(141, 154))
```

The color in the map shows whether a station is an automated one or not and some automated stations are actually pretty close to the traditional ones. We would love to know whether records in these nearby pairs align with each other.
 
## Theory 
 
The two workhorses for matching in a cubble are `match_spatial()` and `match_temporal()`. You can call `match_spatial()` for spatial matching only, or `match_sites()`, which houses both functions, for both spatial and temporal matching. `match_sites()` also has an argument `temporal_matching`, default to `TRUE`, for switching on/off the temporal matching, hence `match_spatial()` and `match_sites(..., temporal_matching = TRUE)` are equivalent. By design, all the arguments that control the temporal matching are prefixed with `temporal_`, so do the arguments for spatial matching. 

Here we will given more details on spatial matching and details on the temporal matching is in the *Theory* section of *Example 2*. A spatial matching requires two datasets: a `major` set and a `minor` set. Spatial matching calculates the spherical distance from *each* site in the `major` dataset to *every* site in the `minor` dataset using the Vincenty formula. 

Once the distance is calculated, three arguments are available to refine the matching results: `spatial_single_match`, `spatial_n_keep`, `spatial_dist_max`.
The order that these three arguments applied will slightly affect the results and in `cubble`, `spatial_n_keep`, default to 1,  is first applied to keep `n` site(s) for each major site, `spaital_dist_max`, default to 10, is then applied to filter out the pairs with distance larger than this maximum distance. `spatial_single_match` is lastly applied to resolve the scenario where site `a` (minor) is the closest match for both site `A` and `B` (major), 5km and 8km respectively, if `spatial_single_match = TRUE`, `a` will only be matched to the major site with the smaller distance, that is,  site `A` here.
  
## Traditional vs. Automated stations   
  
Let's get back to the New South Wales stations - Here we construct the major site `auto` and minor `non_auto` by filtering on whether stations are automated or not. This works in the scenario for examining records from newly-installed automated stations to long-lasting traditional stations (for every newly-installed station, we want to find a nearby traditional one). We apply the spatial matching with `match_sites()` and turn off the temporal matching: 

```{r}
auto <- nsw %>% filter(automated)
non_auto <- nsw %>% filter(!automated)

matched <- match_sites(auto, non_auto, temporal_matching = FALSE) 
```

The result from the pairing is also a cubble with two additional columns:  `.dist` as the distance between the pair and `.group` as the grouping index:

```{r}
matched 
```

Then we can create visualisation to see where these pairs are in the map:

```{r}
plot_map(nsw_map) +
  geom_point(data = matched, 
             aes(x = long, y = lat, color = automated)) + 
  ggrepel::geom_label_repel(data = matched %>% filter(automated),
                            aes(x = long, y = lat, label = .group)) + 
  scale_color_brewer(palette = "Dark2") + 
  ggtitle("New South Wales") + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  coord_sf(xlim = c(141, 154))
```

or compare the series within the same pair (as an example here we only look at records in Jan 2020):

```{r echo = FALSE}
ts <- matched %>%
  switch_key(.group) %>% 
  stretch(ts) %>% 
  migrate(.group) %>% 
  left_join(as_tibble(matched) %>% select(id, automated))

ts %>%
  ggplot(aes(x = date, y = tmax, color = automated, group = id)) +
  geom_line() +
  facet_wrap(vars(.group)) +
  scale_color_brewer(palette = "Dark2") + 
  scale_x_date(date_labels = "%d") + 
  theme_bw()
```

We can see that in general the maximum temperatures recorded in traditional and automated stations from our pairs are matched. There's a constant gap in pair 9, which suggests the two stations need to be further calibrated.

# Example 2

The water level data comes from [Bureau of Meteorology](http://www.bom.gov.au/metadata/catalogue/19115/ANZCW0503900528?template=full) and has a copy in `weatherdata`. Here we extract the water course level and add a column annotate this data of type `river`. For the rainfall data, we will still use the `weatherdata::climate_full`, filtering for Victorian stations in 2020 should be pretty familiar by now. Again, we first look at where these stations are on the map first:

```{r}
river <- weatherdata::water %>% 
  stretch() %>% 
  select(date, Water_course_level) %>% 
  tamp() %>% 
  mutate(type = "river")

climate <- weatherdata::climate_full %>% 
  filter(between(stringr::str_sub(id, 7, 8), 76, 90)) %>% 
  stretch() %>% 
  filter(lubridate::year(date) == 2020) %>% 
  tamp() %>% 
  mutate(type = "climate")

vic_map <- rmapshaper::ms_simplify(ozmaps::abs_ste %>% filter(NAME == "Victoria"))  
plot_map(vic_map) +
  geom_point(data = dplyr::bind_rows(river, climate) , 
             aes(x = long, y = lat, color = type)) + 
  scale_color_brewer(palette = "Dark2") +
  theme_bw()
```

## Theory

Temporal matching checks how spatially matched pairs align temporally. We use the following chart to illustrate how the temporal matching works:

```{r echo = FALSE}
set.seed(123)
dt <- tibble(
  id = factor(c(rep("A", 31), rep("a", 31)), levels = c("A", "a")),
  date = rep(1:31,2),
  val = c(
    c(rnorm(5), 10, rnorm(7), 5 ,rnorm(8), 7, rnorm(8)),
    c(rnorm(6,sd = 0.5), 7, rnorm(7, sd = 0.5), rnorm(6, sd = 0.5), 
      4, rnorm(5,sd = 0.5), 6, rnorm(4,sd = 0.5))
  )
) %>% mutate(val = ifelse(val < 0, 0, val))

circle <- tibble(
  x = c(6, 14, 23, 7, 21, 27), 
  y = c(10, 5, 7, 7, 4, 6), 
  id = factor(c(rep("A", 3), rep("a", 3)), levels = c("A", "a")),
  xend = x + 5
)

errorbar <- bind_rows(circle %>% filter(id == "A"),
                      circle %>% filter(id == "A") %>% mutate(id = "a")) %>% 
  mutate(id = factor(id, c("A", "a")))

fallin <- tibble(id = factor(rep("a", 2), c("A", "a")),
                 x = c(7, 27),
                 y = -0.5,
                 label = "\U2714")

ggplot() + 
  geom_line(data = dt, aes(x = date, y = val, group = id), color = "grey60") + 
  geom_vline(data = circle, aes(xintercept = x), linetype = "longdash", color = "grey60") +
  geom_errorbar(data = errorbar, aes(xmin = x, xmax = xend, y = -0.5), width = 0.5) +
  geom_point(data = circle, aes(x= x, y=y ), color = "brown") +
  geom_text(data = fallin, aes(x = x, y = y, label = label), color = "brown", size = 5) + 
  facet_wrap(vars(id), nrow = 2) + 
  scale_y_continuous(breaks = seq(0,10, 2)) + 
  scale_x_continuous(breaks = seq(1, 31, 1)) + 
  theme_bw() + 
  theme(panel.grid = element_blank()) + 
  labs(x = "Time", y ="Value")
```

For each spatially matched pair, say `A` and `a`, we first find the largest `n` points in each series, colored in brown points here. Here we use the largest three but you can tune this number by `temporal_n_highest`. Then we construct the interval of the largest points from one series and see how many points, from the other series, fall into the intervals. The series used to construct the interval is controlled by `temporal_independent` and the window size by `temporal_window` with a default of 5. 

In this illustration, we construct the interval based on series `A` and two of the three peaks from `a` falls into this interval at Time 7 and 27. 

## Rainfall translates into river level

There's another mandatory argument that hasn't been introduced above: `temporal_var_to_match`. This argument controls the variable to match and it needs to appear in both the `major` and `minor` set. In the water level matching example, we match the variable `Water_course_level` from `river` to `prcp` from `climate`, hence need to manually rename one of them to match the other, here we rename `Water_course_level` to `prcp` in `river`: 

```{r}
river <- river %>% 
  stretch() %>% 
  rename(prcp = Water_course_level) %>% 
  tamp()
```

Now we use `match_sites()` to first pair the weather stations with the river gauges spatially and then apply the temporal matching on `prcp`. We will construct the interval based on peaks in `climate` since we would expect a lag effect for precipitation to flow into the river and cause a raise in river level, hence `temporal_independent = climate`. We select the 30 highest peak from the series to construct the match by setting `temporal_n_highest = 30`. This is a tuning parameter and you can start with 10% of the points of one series (here we have daily data for a year, 10% is roughly 30 points). `temporal_min_match` filters out pairs don't have enough match and to return all the pairs, set `temporal_min_match` to `0`. 


```{r}
res <- match_sites(river, climate,
                   temporal_var_to_match = prcp,
                   temporal_independent = climate,
                   temporal_n_highest = 30,
                   temporal_min_match = 15
)

res
```

The output from temporal matching is also a cubble, with additional column `.dist` and `.group` inherent from spatial matching and `n_match` for the number of matched temporal peaks. Then you can use this output to plot the location of match: 

```{r}
plot_map(vic_map) +
  geom_point(data = res, 
             aes(x = long, y = lat, color = type)) + 
  ggrepel::geom_label_repel(data = res %>% filter(type == "river"),
                            aes(x = long, y = lat, label = .group)) + 
  scale_color_brewer(palette = "Dark2") + 
  ggtitle("Victoria") + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
```

Or to look at the series: 

```{r}
res_long <- res %>% 
  stretch() %>% 
  migrate(.group) %>% 
  mutate(prcp = scale(prcp)[,1]) %>% 
  switch_key(.group) %>% 
  left_join(as_tibble(res) %>% select(.group, type, id))

res_long %>% 
  ggplot(aes(x = date, y = prcp, color = type)) + 
  geom_line() + 
  facet_wrap(vars(.group)) + 
  scale_color_brewer(palette = "Dark2", guide = "none") + 
  theme_bw() + 
  labs(x=  "week") + 
  scale_x_date(date_labels = "%b")

```


---
title: "3. Application: Matching nearby stations"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE,
  message = FALSE,
  out.width = "100%"
)
library(cubble)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(sf)
library(patchwork)
```

One common type of task with spatial temporal data is to match records from nearby sites. For example, we may want to verify if the location of an old list of stations matches up with the current stations, or we may want to investigate if the records from traditional and automated weather stations match up with each other for calibration, or we may want to investigate whether the rainfall will get translated to the river level. Sometimes, matching is only needed on the spatial dimension, while in other cases, the matched pairs also need to be examined on the temporal dimension.  

This vignette will introduce how to perform this type of task in cubble with two examples. The first one is a spatial matching of traditional and automated weather records in New South Wales. The second one matches the rainfall and river level in Victoria. Here we need the temporal matching as well since precipitation may not necessarily translate into river level on the same day. 

# Example 1

In `weatherdata::climate_full`, automated stations in New South Wales are labelled with `aws` in its name. Let's first look at the distribution of these stations on the map: 

```{r}
nsw_map <- ozmaps::abs_ste %>% filter(NAME == "New South Wales")  

nsw <- weatherdata::climate_full %>%   
  filter(between(stringr::str_sub(id, 7, 8), 46, 75)) %>%
  mutate(automated = str_detect(name, "aws")) %>% 
  stretch(ts) %>%
  filter(lubridate::month(date) == 1,
         lubridate::year(date) == 2020) %>% 
  tamp() %>% 
  filter(!any(is.na(ts$tmax)))
 

plot_map(nsw_map) +
  geom_point(data = nsw, 
             aes(x = long, y = lat, color = automated)) + 
  scale_color_brewer(palette = "Dark2") + 
  ggtitle("New Sourth Wales") + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
   coord_sf(xlim = c(141, 154))
```

The color in the map shows whether a station is an automated one or not and we can observe that some automated weather stations are actually close to the traditional ones. This provides a basis to investigate whether numbers recorded by nearby automated and traditional stations match with each other.
 
## Theory 
 
The two working horses for matching in cubble are `match_spatial()` and `match_temporal()`. You can call `match_spatial()` for spatial matching only, or `match_sites()`, which houses both functions, for both spatial and temporal matching. `match_sites()` also has an argument `match_temporal` that default to `TRUE` for switching on/off the temporal matching, hence `match_spatial()` and `match_sites(..., match_temporal = TRUE)` are equivalent. Apart from `match_temporal`, all the arguments that control the temporal matching are prefixed with `temporal_`, so do the arguments for spatial matching. Here we will given more details on spatial matching and see the second example for the details on temporal matching. 

A spatial matching requires two datasets: a `major` set where matches will be found for every site and a `minor` set, which is the candidate pool for matching each site in the major set. Spatial matching calculates the spherical distance from *each* site in the `major` set to *every* sites in the `minor` set using the Vincenty formula. Three arguments are available to refine the matching results: `spatial_single_match`, `spatial_n_keep`, `spatial_dist_max`. Once the distance is calculated, `spatial_n_keep`, default to 1,  is first applied for the number of matching of each major site, `spaital_dist_max`, default to 10, is then applied to filter out the pairs with distance larger than this maximum distance. `spatial_single_match` is lastly applied to resolve the scenario where site `a` (minor) is the closest match for both site `A` and `B` (major), if `spatial_single_match = TRUE`, `a` will be matched to the major site with the smaller distance.
  
## Traditional vs. Automated stations   
  
Let's get back to the New South Wales stations - Here we construct `auto` and `non_auto` by filtering on whether stations are automated or not. In this example, there's no different on  which one is the major data since both will give the same result, but in the later river example, this distinction will be necessary. We use `match_sites()` on both datasets and turn off the temporal matching: 

```{r}
auto <- nsw %>% filter(automated)
non_auto <- nsw %>% filter(!automated)

matched <- match_sites(auto, non_auto, match_temporal = FALSE) 
```

The result is also a cubble of matched pairs, with additional column `.dist` and `.group` for distance and grouping index:

```{r}
matched 
```

Then we can create visualisation to see where these station are in the nested cubble:

```{r}
plot_map(nsw_map) +
  geom_point(data = matched, 
             aes(x = long, y = lat, color = automated)) + 
  ggrepel::geom_label_repel(data = matched %>% filter(automated),
                            aes(x = long, y = lat, label = .group)) + 
  scale_color_brewer(palette = "Dark2") + 
  ggtitle("New South Wales") + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  coord_sf(xlim = c(141, 154))
```

or compare the series within the same pair using the long cubble (as an example here we only look at records in Jan 2020):

```{r echo = FALSE}
ts <- matched %>%
  switch_key(.group) %>% 
  stretch(ts) %>% 
  migrate(.group) %>% 
  left_join(as_tibble(matched) %>% select(id, automated))

ts %>%
  ggplot(aes(x = date, y = tmax, color = automated, group = id)) +
  geom_line() +
  facet_wrap(vars(.group)) +
  scale_color_brewer(palette = "Dark2") + 
  scale_x_date(date_labels = "%d") + 
  theme_bw()
```

We can see that in general the maximum temperatures recorded in traditional and automated stations from our pairs are matched. There's a constant gap in pair 9, which suggests the two stations need to be further calibrated.

# Example 2

The water level data comes from [Bureau of Meteorology](http://www.bom.gov.au/metadata/catalogue/19115/ANZCW0503900528?template=full) and has a copy in `weatherdata`. Here we extract the water course level and add a column annotate this data of type `river`. For the rainfall data, we will still use the `weatherdata::climate_full`, filtering for Victorian stations in 2020 should be pretty familiar by now. Again, we first look at where these stations are on the map first:

```{r}
river <- weatherdata::water %>% 
  stretch() %>% 
  select(date, Water_course_level) %>% 
  tamp() %>% 
  mutate(type = "river")

climate <- weatherdata::climate_full %>% 
  filter(between(stringr::str_sub(id, 7, 8), 76, 90)) %>% 
  stretch() %>% 
  filter(lubridate::year(date) == 2020) %>% 
  tamp() %>% 
  mutate(type = "climate")

vic_map <- rmapshaper::ms_simplify(ozmaps::abs_ste %>% filter(NAME == "Victoria"))  
plot_map(vic_map) +
  geom_point(data = dplyr::bind_rows(river, climate) , 
             aes(x = long, y = lat, color = type)) + 
  scale_color_brewer(palette = "Dark2") +
  theme_bw()
```

## Theory

Temporal matching checks how spatially matched pairs align temporally. We use the following chart to illustrate how the temporal matching works:

```{r echo = FALSE}
set.seed(123)
dt <- tibble(
  id = factor(c(rep("A", 31), rep("a", 31)), levels = c("A", "a")),
  date = rep(1:31,2),
  val = c(
    c(rnorm(5), 10, rnorm(7), 5 ,rnorm(8), 7, rnorm(8)),
    c(rnorm(6,sd = 0.5), 7, rnorm(7, sd = 0.5), rnorm(6, sd = 0.5), 
      4, rnorm(5,sd = 0.5), 6, rnorm(4,sd = 0.5))
  )
) %>% mutate(val = ifelse(val < 0, 0, val))

circle <- tibble(
  x = c(6, 14, 23, 7, 21, 27), 
  y = c(10, 5, 7, 7, 4, 6), 
  id = factor(c(rep("A", 3), rep("a", 3)), levels = c("A", "a")),
  xend = x + 5
)

errorbar <- bind_rows(circle %>% filter(id == "A"),
                      circle %>% filter(id == "A") %>% mutate(id = "a")) %>% 
  mutate(id = factor(id, c("A", "a")))

fallin <- tibble(id = factor(rep("a", 2), c("A", "a")),
                 x = c(7, 27),
                 y = -0.5,
                 label = "\U2714")

ggplot() + 
  geom_line(data = dt, aes(x = date, y = val, group = id), color = "grey60") + 
  geom_vline(data = circle, aes(xintercept = x), linetype = "longdash", color = "grey60") +
  geom_errorbar(data = errorbar, aes(xmin = x, xmax = xend, y = -0.5), width = 0.5) +
  geom_point(data = circle, aes(x= x, y=y ), color = "brown") +
  geom_text(data = fallin, aes(x = x, y = y, label = label), color = "brown", size = 5) + 
  facet_wrap(vars(id), nrow = 2) + 
  scale_y_continuous(breaks = seq(0,10, 2)) + 
  scale_x_continuous(breaks = seq(1, 31, 1)) + 
  theme_bw() + 
  theme(panel.grid = element_blank()) + 
  labs(x = "Time", y ="Value")
```

For each spatially matched pair, say `A` and `a`, we first find the largest `n` points in each series, colored in brown points here. Here we use the largest three but you can tune this number by `temporal_n_highest`. Then we construct the interval of the largest points from one series and see how many points, from the other series, fall into the intervals. The series used to construct the interval is controlled by `temporal_independent` and the window size by `temporal_window` with a default of 5. 

In this illustration, we construct the interval based on series `A` and two of the three peaks from `a` falls into this interval at Time 7 and 27. 

## Rainfall translates into river level

There's another mandatory argument that hasn't been introduced above: `temporal_var_to_match`. This argument controls the variable to match and it needs to appear in both the `major` and `minor` set. In the water level matching example, we match the variable `Water_course_level` from `river` to `prcp` from `climate`, hence need to manually rename one of them to match the other, here we rename `Water_course_level` to `prcp` in `river`: 

```{r}
river <- river %>% 
  stretch() %>% 
  rename(prcp = Water_course_level) %>% 
  tamp()
```

Now we use `match_sites()` to first pair the weather stations with the river gauges spatially and then apply the temporal matching on `prcp`. We will construct the interval based on peaks in `climate` since we would expect a lag effect for precipitation to flow into the river and cause a raise in river level, hence `temporal_independent = climate`. We select the 30 highest peak from the series to construct the match by setting `temporal_n_highest = 30`. This is a tuning parameter and you can start with 10% of the points of one series (here we have daily data for a year, 10% is roughly 30 points). `temporal_min_match` filters out pairs don't have enough match and to return all the pairs, set `temporal_min_match` to `0`. 


```{r}
res <- match_sites(river, climate,
                   temporal_var_to_match = prcp,
                   temporal_independent = climate,
                   temporal_n_highest = 30,
                   temporal_min_match = 15
)

res
```

The output from temporal matching is also a cubble, with additional column `.dist` and `.group` inherent from spatial matching and `n_match` for the number of matched temporal peaks. Then you can use this output to plot the location of match: 

```{r}
plot_map(vic_map) +
  geom_point(data = res, 
             aes(x = long, y = lat, color = type)) + 
  ggrepel::geom_label_repel(data = res %>% filter(type == "river"),
                            aes(x = long, y = lat, label = .group)) + 
  scale_color_brewer(palette = "Dark2") + 
  ggtitle("Victoria") + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
```

Or to look at the series: 

```{r}
res_long <- res %>% 
  stretch() %>% 
  migrate(.group) %>% 
  mutate(prcp = scale(prcp)[,1]) %>% 
  switch_key(.group) %>% 
  left_join(as_tibble(res) %>% select(.group, type, id))

res_long %>% 
  ggplot(aes(x = date, y = prcp, color = type)) + 
  geom_line() + 
  facet_wrap(vars(.group)) + 
  scale_color_brewer(palette = "Dark2", guide = "none") + 
  theme_bw() + 
  labs(x=  "week") + 
  scale_x_date(date_labels = "%b")

```


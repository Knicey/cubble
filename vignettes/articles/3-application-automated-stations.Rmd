---
title: "3. Application: Matching nearby stations"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE,
  message = FALSE,
  out.width = "100%"
)
library(cubble)
library(dplyr)
library(tidyr)
library(stringr)
library(ggplot2)
library(sf)
library(patchwork)
```

One common type of task with spatial temporal data is to match records from nearby sites. For example, we may want to verify if the location of an old list of stations matches up with the current stations, or we may want to investigate if the records from traditional and automated weather stations match up with each other for calibration, or we may want to investigate whether the rainfall will get translated to the river level. All of these tasks involve finding nearby pairs from two data tables.

This vignette will introduce how to perform this type of task in cubble with an example of matching traditional and automated weather station records in New South Wales. New South Wales is selected since automated stations there are labelled with `aws` in its name. Let's first look at the distribution of these station on the map: 

```{r}
nsw_map <- ozmaps::abs_ste %>% filter(NAME == "New South Wales")  

nsw <- weatherdata::climate_full %>%   
  filter(between(stringr::str_sub(id, 7, 8), 46, 75)) %>%
  mutate(automated = str_detect(name, "aws")) %>% 
  stretch(ts) %>%
  filter(lubridate::month(date) == 1,
         lubridate::year(date) == 2020) %>% 
  tamp() %>% 
  filter(!any(is.na(ts$tmax)))
 

plot_map(nsw_map) +
  geom_point(data = nsw, 
             aes(x = long, y = lat, color = automated)) + 
  scale_color_brewer(palette = "Dark2") + 
  ggtitle("New Sourth Wales") + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
   coord_sf(xlim = c(141, 154))
```

The color in the map shows whether a station is an automated one or not and we can observe that some automated weather stations are actually close to the traditional ones. This provides a basis to investigate whether numbers recorded by nearby automated and traditional stations match with each other.

To find pairs of nearby stations, you can use `match_key()`. The function requires two datasets: a major set where matches will be found for every station and a minor set, which is the candidate pool for matching each station in the major set. It then calculates the spherical distance between each pair combination. Argument `n_slice` and `dist_max` are used to control the number of match to find for each site in the major dataset and the maximum distance allowed. The default value is `n_slice = 1` and `dist_max = 10`. 

Here we construct two datasets by filtering on whether they are automated or not and want to find the closest traditional station for each automated station if their distance is less than 10 kilometer:

```{r}
auto <- nsw %>% filter(automated)
non_auto <- nsw %>% filter(!automated)

matched <- match_sites(auto, non_auto, match_temporal = FALSE) 
matched 
```

Then we can create visualisation to see where these station are in the nested cubble:

```{r}
plot_map(nsw_map) +
  geom_point(data = matched, 
             aes(x = long, y = lat, color = automated)) + 
  ggrepel::geom_label_repel(data = matched %>% filter(automated),
                            aes(x = long, y = lat, label = .group)) + 
  scale_color_brewer(palette = "Dark2") + 
  ggtitle("New Sourth Wales") + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank()) +
  coord_sf(xlim = c(141, 154))
```

or compare the series within the same pair using the long cubble (as an example here we only look at records in Jan 2020):

```{r echo = FALSE}
ts <- matched %>%
  switch_key(.group) %>% 
  stretch(ts) %>% 
  migrate(.group) %>% 
  left_join(as_tibble(matched) %>% select(id, automated))

ts %>%
  ggplot(aes(x = date, y = tmax, color = automated, group = id)) +
  geom_line() +
  facet_wrap(vars(.group)) +
  scale_color_brewer(palette = "Dark2") + 
  scale_x_date(date_labels = "%d") + 
  theme_bw()
```

We can see that in general the maximum temperatures recorded in traditional and automated stations from our pairs are matched. There's a constant gap in pair 7, which suggests the two stations need to be further calibrated.


```{r}
river <- weatherdata::water %>% 
  stretch() %>% 
  select(date, Water_course_level) %>% 
  tamp() %>% 
  mutate(type = "river")

climate <- weatherdata::climate_full %>% 
  filter(between(stringr::str_sub(id, 7, 8), 76, 90)) %>% 
  stretch() %>% 
  filter(lubridate::year(date) == 2020) %>% 
  tamp() %>% 
  mutate(type = "climate")

vic_map <- rmapshaper::ms_simplify(ozmaps::abs_ste %>% filter(NAME == "Victoria"))  
plot_map(vic_map) +
  geom_point(data = dplyr::bind_rows(river, climate) , 
             aes(x = long, y = lat, color = type)) + 
  scale_color_brewer(palette = "Dark2") +
  theme_bw()

river <- river %>% 
  stretch() %>% 
  rename(prcp = Water_course_level) %>% 
  tamp()
```

```{r}
res <- match_sites(river, climate, 
            temporal_var_to_match = prcp,
            temporal_independent = climate, 
            temporal_n_highest = 30, 
            temporal_min_match = 15)
```

```{r}
plot_map(vic_map) +
  geom_point(data = res, 
             aes(x = long, y = lat, color = type)) + 
  ggrepel::geom_label_repel(data = res %>% filter(type == "river"),
                            aes(x = long, y = lat, label = .group)) + 
  scale_color_brewer(palette = "Dark2") + 
  ggtitle("Victoria") + 
  theme_minimal() + 
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
```


```{r}
res_long <- res %>% 
  stretch() %>% 
  migrate(.group) %>% 
  mutate(prcp = scale(prcp)[,1]) %>% 
  switch_key(.group) %>% 
  left_join(as_tibble(res) %>% select(.group, type, id))

res_long %>% 
  ggplot(aes(x = date, y = prcp, color = type)) + 
  geom_line() + 
  facet_wrap(vars(.group)) + 
  scale_color_brewer(palette = "Dark2", guide = "none") + 
  theme_bw() + 
  labs(x=  "week") + 
  scale_x_date(date_labels = "%b")

```


---
title: "0. Import data as a cubble"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE,
  message = FALSE
)

library(cubble)
library(rnoaa)
library(dplyr)
library(patchwork)
library(ggplot2)
library(sf)
```

This article shows you how to create a cubble from data in the wild.  Three examples are given to construct a cubble from:  

  - a tibble 
  - a tsibble 
  - NetCDF data
  
## A cubble from tibble

You should have already seen an example of constructing a cubble from a tibble in the README page, here we show an example of turning a row-wise data frame into cubble. A row-wise data frame can be a useful structure when querying data from a database since you can first create a row-wise data frame with all the metadata and then query the data as a nested list. We will show how to convert this row-wise output into a cubble with climate data.

Suppose we are interested in the climate stations close to Melbourne and Sydney, here are ten of them: 

```{r echo = FALSE}
latlon_ref <- tibble::tibble(id = c("sydney", "melbourne"),
                         lat = c(-33.8675, -37.8136),
                         long = c(151.2070, 144.9631))

master_list <- climate_aus %>% 
   as_tibble() %>% 
   select(id, lat, long, elev, name, wmo_id)

calc_dist <- function(df_ref, df, n = 5){
  long_ref <- df_ref$long
  lat_ref <- df_ref$lat
  
  df %>% 
    mutate(long_ref = long_ref,
           lat_ref=  lat_ref,
           dist = rnoaa::meteo_spherical_distance(lat, long,lat_ref, long_ref)) %>% 
    slice_min(dist, n = n) %>% 
    mutate(city = df_ref$id) %>% 
    select(-long_ref, -lat_ref)
}

stations <- do.call("rbind", purrr::map(1:nrow(latlon_ref), 
                             ~calc_dist(latlon_ref[.x, ], master_list)))
```

```{r}
stations
```

Such a dataset can be constructed via subsetting a station master list, i.e. `rnoaa::ghcnd_stations()`, with some criteria on variable, distance and recording years. The time series of climate variables can be queried by `rnoaa::meteo_pull_monitors()` with the date range and variable supplied. Here we turn the `stations` data into a rowwise data frame and then query the climate variables as a list-column, `ts`:  

```{r}
raw <- stations %>% 
  rowwise() %>% 
  mutate(ts = list(rnoaa::meteo_pull_monitors(id, 
                                       date_min = "2020-01-01", 
                                       date_max = "2020-12-31",
                                       var = c("PRCP", "TMAX", "TMIN")))) 
raw
```

The nested data is then ready to be turned into a cubble with: 

  - `id` as the key to identify each station, 
  - `date` as the index to identify time, and 
  - `coords` to identify the spatial coordinates of each station.

```{r}
sydmel_climate <- raw %>% 
  as_cubble(key = id, index = date, coords = c(long, lat))

sydmel_climate
```

# A cubble from tsibble

Suppose we have a tsibble from `climate_flat`:

```{r}
dt <- climate_flat %>% 
  tsibble::as_tsibble(key = id, index = date)
dt
```

We can create a cubble out of the tsibble only with the additional `coords` argument: 

```{r}
cb <- dt %>% as_cubble(coords = c(long, lat))
cb
```

Notice here each element of the list-column \code{ts} is a \code{tbl_ts} class and you are free to apply your favourite function on the tsibble class :)

# A cubble from NetCDF data

NetCDF data may not be familiar to everyone and here we provide some background information on this data format. If you're comfortable with NetCDF, feel free to skip the next few paragraphs.

NetCDF (Network Common Data Form) is a commonly used data format in the climatology community to deliver global mapping of atmosphere, ocean, and land. It has two main components: 

  - **dimension**: define the spatio-temporal grid (longitude, latitude, and time) and 
  - **variable**: populate the defined grid. 
  
Attributes are usually associated with dimension and variable in the NetCDF format data. A few packages in R exists for manipulating NetCDF data and this includes a high-level R interface: `ncdf4`, a low-level interface that calls C interface: `RNetCDF`, and a tidyverse implementation: `tidync`. Here let's take a look at a NetCDF data: 

```{r}
path <- system.file("ncdf/era5-pressure.nc", package = "weatherdata")
raw <- ncdf4::nc_open(path)
raw
```

In a NetCDF data, it is not the the actual data that gets directly printed out, but the metadata. There are 2 variables and 3 dimensions in this data and each is associated with a few attributes. In this data the attributes for the two variables includes the scaling and offset parameter, representation of the missing and its fill value, along with its unit and names. In NetCDF, data is stored in its *packed value* to save space and sometimes, you will need to use a formula like $\text{unpacked value} = \text{packed value} \times \text{scale factor} + \text{add offset}$ to unpack the data. Luckily, when reading in the NetCDF data with the `ncdf4` package, it has already unpack the data for you, so no need to worry about the scaling and offset. 

In principle, NetCDF data can store data with arbitrary variable, dimension, and attribute and this will cause a chaos to generalise its manipulation. [Metadata convention for climate and forecast (CF convention)](http://cfconventions.org/) is a guideline that has been designed to standardise the format of NetCDF data. Thanks to the CF convention, `cubble` can now extract specific components as per the CF convention to build a cubble from NetCDF data. Cubble provides an `as_cubble()` method to coerce the `ncdf4` class from the `ncdf4` package into a cubble. It maps each combination of longitude and latitude into an `id` as the key:

```{r}
dt <- as_cubble(raw, vars = c("q", "z"))
dt
```

The memory limit with NetCDF data in cubble depends on longitude grid point x latitude grid point x time grid point x number of variable. Cubble can handle slightly more than 300 x 300 (longitude x longitude) grid points for 3 variables in one year. You can reduce the spatial grid points in exchange for longer time period and more variables. A 300 by 300 spatial grid can be:
  
  - a bounding box of [100, -80, 180, 0] at 0.25 degree resolution, or 
  - a global bounding box [-180, -90, 180, -90] at 1 degree resolution. 
  
Subsetting longitude and latitude grid is available through `long_range` and `lat_range` if the NetCDF file has finer resolution than needed.

```{r}
dt <- as_cubble(raw, vars = c("q", "z"),
                long_range = seq(-180, 180, 1),
                lat_rnage = seq(-90, -5, 1))
dt
```


---
title: "2. Data manipulation with cubble"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE, 
  warning = FALSE,
  out.width = "100%"
)
```

```{r setup, echo = FALSE}
library(dplyr)
library(cubble)
library(ggplot2)
library(GGally)
```

For spatio-temporal data, one may want to plot the time series on the map to observe the spatial relationship among sites close to each other. A glyph map allows you to inset the time series, as a glyph, into the map to detect any global or local pattern. Below is an example of the monthly maximum temperature collected from 61 stations in Australia in 2020.

```{r fig.height=7, fig.width=10, echo = FALSE,  fig.align='center'}
state_map <- rmapshaper::ms_simplify(ozmaps::abs_ste, keep = 5e-3)

out <- aus_climate %>% 
  stretch() %>% 
  filter(lubridate::year(date) == 2020) %>% 
  mutate(ym = tsibble::yearmonth(date)) %>% 
  group_by(ym) %>% 
  summarise(tmax = mean(tmax, na.rm = TRUE)) %>% 
  migrate(lat, long)

gly_dt <- glyphs(out, 
                 x_major = "long", y_major = "lat", 
                 x_minor = "ym", y_minor = "tmax", 
                 height = 1, width = 2)

plot_map(state_map) + 
  ggplot2::geom_path(data = gly_dt, ggplot2::aes(gx, gy, group = gid))
```

To be able to produce the glyph map above, two tasks need to done: 

  - filter out only the 2020 records
  - summarise the daily maximum temperature into monthly measure

# Mutate and filter

Filtering 2020 records is an operation on the time dimension since it requires to decide whether the year component of the date is 2020. A cubble processes all the time dimension operations using the long form, so we first use `stretch()` to switch the data to the long form and then filter on the year:

```{r}
long <- aus_climate %>% 
  stretch() %>% 
  filter(lubridate::year(date) == 2020)
long
```

# Summarise

Daily measures are usually too sparse to be plotted and aggregation is a common treatment for this. Next, we will aggregate the daily maximum temperature into monthly measure and since this is a time-wise operation involving `date`, we need to switch to the long cubble:

We create a `ym` variable from `tsibble::yearmonth()` and add an additional grouping on `ym` with `group_by()`. This allows us create a summary for each station in each month in the next step: 

```{r}
summarised_long <- long %>% 
  mutate(ym = tsibble::yearmonth(date)) %>% 
  group_by(ym) %>% 
  summarise(tmax = mean(tmax, na.rm = TRUE))
summarised_long
```

This gives all we need to make the time series glyph, let's see how they look like in a grid view: 

```{r fig.height=7, fig.width=10}
summarised_long %>% 
  ggplot(aes(x = ym, y = tmax)) + 
  geom_line() +
  facet_wrap(vars(forcats::fct_reorder(id, -tmax))) +
  tsibble::scale_x_yearmonth(date_labels = "%b") + 
  xlab("month")
```

# Join

A glyph map requires a  set of major coordinate (`x_major` and `y_major`) and minor coordinate (`x_minor` and `y_minor`) to locate the glyph in the map. In our case, the major axes are `long` and `lat` and minor axes are `date` and `tmax`. One last step before making the glyph map is to collect these variables in one table and this can be done with `migrate()`, which moves the time-invariant variables in the nested form into the long form: 

```{r}
migrated <- summarised_long %>% 
  migrate(lat, long)
migrated
```


# Glyph map

Now let's use `glyphs` from `GGally` to create the glyph data and here you go, the glyph map you see in the beginning of this vignette!

```{r fig.height=7, fig.width=7, fig.align='center'}
state_map <- rmapshaper::ms_simplify(ozmaps::abs_ste, keep = 5e-3)
gly_dt <- GGally::glyphs(migrated, 
                 x_major = "long", y_major = "lat", 
                 x_minor = "ym", y_minor = "tmax", 
                 height = 1, width = 2)

plot_map(state_map) + 
  geom_path(data = gly_dt, aes(gx, gy, group = gid))
```


In the code above, the map underlayed is from `ozmaps::abs_ste` and `rmapshaper::ms_simplify()`  simplifies the map by keeping only a proportion of points along the coastline to avoid unnecessary details. `plot_map()` is a function in `cubble` that wraps around `ggplot() + geom_sf(data, ...)` with some default aesthetic: `color = "grey80", alpha = 0.4, linetype = 3,` to save some typing. 

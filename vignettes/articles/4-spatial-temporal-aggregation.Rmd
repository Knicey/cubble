---
title: "4. Application: Spatial and temporal aggregation"
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE, 
  message = FALSE,
  cache = TRUE, # currently mutate(ll = s2_lnglat(long, lat)) is a bit slow
  out.width = "100%"
)
library(dplyr)
library(cubble)
library(s2)
library(sf)
library(ggplot2)
library(patchwork)
```

On top of `aus_climate` data in this package, `climate_full` from package [`weatherdata`](https://github.com/huizezhang-sherry/weatherdata) has daily climate data of `r nrow(weatherdata::climate_full)` Australia stations from 2016 to 2020. This is where these stations locate in an Australia map: 

```{r}
state_map <- rmapshaper::ms_simplify(ozmaps::abs_ste, keep = 2e-3)
plot_map(state_map) +
  geom_point(data = weatherdata::climate_full , aes(x = long, y = lat))
```

This is a lot of stations to look at for one climate variable and they can't all fit into a glyph map. What we can do is to group stations into clusters and look at the aggregated series in the glyph map. In this vignette, I will introduce how to perform spatial (and temporal) aggregation using hierarchical data structure in cubble. 

First let's add a new column `ll` for calculating distance matrix in the next section and aggregate the daily precipitation into weekly measure. These steps should be familiar from the vignette *Data manipulation with cubble*.

```{r}
station_nested <- weatherdata::climate_full %>% 
  mutate(ll = s2_lnglat(long, lat))  %>% 
  stretch() %>% 
  mutate(wk = lubridate::week(date)) %>% 
  group_by(wk) %>% 
  summarise(prcp = sum(prcp, na.rm = TRUE)) %>% 
  tamp()
```

# Hierarchical data structure

Imposing a clustering structure can be thought of as building a hierarchical structure where stations are nested within clusters. As an example to illustrate here, we use a kmean clustering algorithm based on the distance matrix and specify the number of centers to be 20. More complex algorithms can also be used for more complex problem, as long as a mapping from each station id to the cluster id can be constructed. We then join this data to our station data:

```{r}
dist_raw <- scale(s2_distance_matrix(station_nested$ll, station_nested$ll))

cluster_res <- tibble(id = station_nested$id,
                      cluster = kmeans(dist_raw, centers = 20, nstart = 50)$cluster)

station_nested <- station_nested %>% 
  left_join(cluster_res) 
station_nested %>% head(5)
```

One thing we hope to do with the cluster is to find the coordinates of the centroid. These are variables variant to the station but invariant to the cluster and it would be nice to have a function that structure each cluster as a row. `switch_key()` is the function that does this: it lets you to specify a new key, say `cluster` and nests all spatial variables variant to `cluster` into a column. Temporal observations from different stations while within the same cluster are bound in the nested column `ts`.

```{r}
cluster_nested <- station_nested %>% 
  switch_key(cluster)
cluster_nested %>% head(5)
```

This structure makes it easy to compute cluster level variable, although there are a few steps to calculate the centroid coordinates: we need to find the convex hull that wraps around the cluster, make it a polygon, find the centroid of the polygon and finally, extract the x and y coordinate of each centroid:

```{r}
cluster_nested <- cluster_nested %>% 
  mutate(chull = list(chull(val$long, val$lat)),
         ll_cluster = sf::st_as_sfc(
           s2_make_polygon(c(val$long[chull]), 
                           c(val$lat[chull]), oriented = FALSE)),
         centroid = s2_centroid(ll_cluster),
         cent_long = s2_x(centroid),
         cent_lat = s2_y(centroid)) 
cluster_nested %>% head(5)
```

# Now it's time to look at the Australia precipitation 

After we have got `cluster_nested`, spatial and temporal data at both levels can be easily obtained. If we use `station` and `cluster` prefix to denote the two levels and `nested` and `long` for whether the data shows the spatial or temporal dimension, the relationship among the four datasets can be illustrated in the following workflow:

```{r echo = FALSE}
knitr::include_graphics(here::here("man/figures/hier-workflow.png"))
```

Start with the original `station_nested`, `stretch()` expands the `ts` column with each station (`id`) forming a group and attach variables invariant to `id` as an attribute. `switch_key()` changes the `key` from `id` to `cluster` and nests all the spatial variables that variant to `cluster`. `stretch()` `cluster_nested` will store variables that are invariant to `cluster` as a tibble in the attribute.

## Aggregated overview

Now we can obtain the aggregated series as described in the workflow diagram above and construct the glyph map with `GGally::glyphs()`: 

```{r}
cluster_long <- cluster_nested %>% 
  stretch(ts) %>% 
  group_by(wk) %>% 
  summarise(prcp = sum(prcp, na.rm = TRUE)) %>% 
  migrate(cent_long, cent_lat)

cluster_long %>% head(5)

gly <- GGally::glyphs(cluster_long, 
                      x_major = "cent_long", x_minor = "wk",
                      y_major = "cent_lat", y_minor = "prcp", 
                      height = 2, width = 4)

plot_map(state_map) + 
  geom_text(data = cluster_nested, 
            aes(x = cent_long, y = cent_lat, label = cluster)) + 
  geom_path(data = gly, 
            aes(x = gx, y = gy, group = gid))
```

## Individual series within the cluster

We can also look at the precipitation of each individual station within the same cluster: 

```{r}
station_long <- station_nested %>% 
  stretch(ts) %>% 
  migrate(cluster)

station_long %>% head(5)

station_long %>% 
  ggplot(aes(x = wk, y = prcp, group = id)) + 
  geom_line(alpha = .3) + 
  facet_wrap(vars(cluster), scales = "free_y", ncol = 4) + 
  theme_bw()
```

## Spot the weirdo

Lastly, there is one series on Tasmania island standing out from others, lets look at where it is: 

```{r}
# this part still needs some fixing
tas_latlong <- station_nested %>%
  filter(lat < -40) %>%  
  mutate(p = max(ts$prcp)) %>% 
  strip_rowwise() %>% 
  filter(p == max(p))

state_map <- rmapshaper::ms_simplify(ozmaps::abs_ste, keep = 2e-3)
plot_map(state_map) + 
  geom_point(data = station_nested, aes(x = long, y = lat), size = 0.5) + 
  geom_sf(data = cluster_nested, aes(geometry = ll_cluster), fill = "transparent") +
  geom_point(data = tas_latlong, aes(x = long, y = lat), col = "red")

```

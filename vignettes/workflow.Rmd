---
title: "workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE, 
  warning = FALSE
)
```

```{r setup}
library(cubble)
library(tsibble)
library(lubridate)
library(dplyr)
```

# Create a cubble

A cubble object uses a list-column form and a long form, powered by the `rowwise_df` and `grouped_df`, to allow flexible group-wise and time-wise computation for spatial-temporal data.

To create a cubble object in the list-column form, use `global()` with a supply of the grouping variable. This would add `cubble_df` and `rowwise_df` to the underlying data structure the object is built upon. On top of the attributes inherent from tibble (`name` and `row.names`) and rowwise_df (`groups`), a cubble has two additional attributes: `meta` and `form`. `meta` stores the group-wise information so that the object can be switched between the list-column and long form without the lost of information while `form` specifies whether the data object is a list-column or long form.

In the list-column form, each distinct key value constitutes a row and all the time-specific measures are nested into a column named `ts`. This form is convenient for calculating group-wise measures.

```{r}
oz_global <- oz_climate  %>% global(station)
oz_global
```

`zoom()` switches a cubble object into the long form where all the group-specific variables are suppressed into the `meta` attributes. This form is time-centric and is useful to compute time-wise variables.

```{r}
oz_zoom <- oz_global %>% zoom()
oz_zoom
```

The long form and the list-column form can be switched between each other by using `global()` on a long form cubble and `zoom()` on a list-column cubble. Since a cubble has a grouping variable as an attribute, there's no need to specify the grouping variable again.

```{r}
back <- oz_zoom %>% global()
back
```

# Manipulation

## Work with dplyr verbs

Currently, verbs in the `dplyr` package supported by cubble includes `filter`, `mutate`, `summarise`. In the example below, we want to only focus on the 2020 record and remove the stations that don't have tmax recorded.  Since the calculation is time-specific, we start with the time-wise long form.

TODO: write down how to do

```{r}
# station ASN00004032 don't have tmax recorded at all. We want to remove stations like these
# detect problemetic stations
oz_global %>% filter(station == "ASN00004032") %>% pull(ts)

time_wise <- oz_zoom %>%
  filter(year(date) == 2020) %>% 
  global() %>% 
  mutate(tmax_missing = sum(ts$tmax, na.rm = TRUE)) %>% 
  filter(tmax_missing != 0) %>% 
  zoom()
  
time_wise 
```

Joining can be performed on both the long/ list-column form. Variable joined that are group-specific will also be added to the `meta` attributes. 

```{r}
# join wmo_id for each station
to_join <- station %>% select(id, wmo_id)
joined <- oz_global %>% 
  left_join(to_join, by = c("station" = "id")) %>% 
  zoom()
joined
meta(joined) %>% head()
```

A shortcut for joining variables from metadata to the long form is via `migrate()`. This can be useful for creating visualisation that involves both the group-wise and time-wise variables, i.e. glyph map. 

```{r}
oz_zoom %>% 
  migrate(lat, long) 
```



## Time series as a tsibble object

Cubble also support a tsibble data structure for time series computation. 

A cubble can also be created from a tsibble object, this time, in the list-column form, each item in the `ts` column is a tsibble, rather than tibble object and in the long form, the object is by default a tsibble object.

```{r}
oz_climate_tsibble <- oz_climate %>% tsibble::as_tsibble(index = date, key = station)
oz_global2 <- oz_climate_tsibble %>% global(station)
oz_zoom2 <- oz_global2 %>% zoom()

oz_global2
oz_zoom2
```

With a tsibble structure, we can further make the summary above into monthly summary by using the `index_by` function in `tsibble`:

```{r}
time_wise2 <- oz_zoom2 %>% 
  filter(lubridate::year(date) >= 2015, station == "ASN00001019") %>% 
  mutate(ym = tsibble::yearmonth(date)) %>% 
  tsibble::index_by(ym) %>% 
  summarise(prcp = sum(prcp, na.rm = TRUE),
            across(tmax:tmin, ~mean(.x, na.rm = TRUE)))

time_wise2
# has a problem to switch back to list-column form since now there are two keys: station, ym
```

## Sampling and add missing summary

`sample_group_var()` makes random sampling of the grouping variable for plotting. It is similar to `brolgar::sample_n_keys()` but the brolgar function doesn't deal with class `grouped_df`.

```{r}
oz_global2 %>% 
  sample_group_var(size = 10) 
```


Missing summary gives a better view of the data quality recorded in each station. 

  - `add_missing_prct()` binds `{VAR}_missing` columns to calculate the percentage of missing for  each station.
  - `add_missing_dscrb()` categories the percentage missing calculated into three categories:  almost no missing, some missing, and almost all missing. The two cutoff values can be specified for switching between categories. This categorisation is to be further used for the viz [more on this].

```{r}
oz_global2 %>% 
  add_missing_prct(prcp:tmin) %>% 
  add_missing_dscrb()
```



# Old stuff

```{r}
count_var <- function(dt){
  dt %>% 
    as_tibble() %>% 
    pivot_longer(prcp:tavg, names_to = "datatype", values_to = "value") %>% 
    group_by(datatype) %>% 
    # think of a better way to filter out those block missing
    summarise(missing = sum(value, na.rm = TRUE)) %>% 
    filter(missing != 0) %>% nrow()
}

```

* some functions to unnest into a tsibble structure, tried unnest_tsibble/ unnest
* some functions to move variables in/ out of nested list - migrate
* some functions to allow data masking within list
* reproduce old result: think about how would you plot the data with list-column structure

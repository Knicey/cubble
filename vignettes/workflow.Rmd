---
title: "workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE, 
  warning = FALSE
)
```

```{r setup}
library(cubble)
library(tsibble)
library(lubridate)
library(dplyr)
```

# Create a cubble

A cubble object uses a list-column form and a long form, powered by the `rowwise_df` and `grouped_df`, to allow flexible group-wise and time-wise computation for spatial-temporal data.

To create a cubble object in the list-column form, use `global()` with a supply of the grouping variable. This would add `cubble_df` and `rowwise_df` to the underlying data structure the object is built upon. On top of the attributes inherent from tibble (`name` and `row.names`) and rowwise_df (`groups`), a cubble has two additional attributes: `meta` and `form`. `meta` stores the group-wise information so that the object can be switched between the list-column and long form without the lost of information while `form` specifies whether the data object is a list-column or long form.

In the list-column form, each distinct key value constitutes a row and all the time-specific measures are nested into a column named `ts`. This form is convenient for calculating group-wise measures.

```{r}
oz_global <- climate_flat  %>% global(station)
oz_global
```

`zoom()` switches a cubble object into the long form where all the group-specific variables are suppressed into the `meta` attributes. This form is time-centric and is useful to compute time-wise variables.

```{r}
oz_zoom <- oz_global %>% zoom()
oz_zoom
```

The long form and the list-column form can be switched between each other by using `global()` on a long form cubble and `zoom()` on a list-column cubble. Since a cubble has a grouping variable as an attribute, there's no need to specify the grouping variable again.

```{r}
back <- oz_zoom %>% global()
back
```

# Manipulation

## Work with dplyr verbs

Below are three examples on how to manipulate a cubble object with dplyr verbs:

### Example 1 

In the first example, we want to only keep the stations that have `tmax` recorded in 2020. This requires first narrow down the records to those in 2020, determine if `tmax` is missing for each station, and then retain those stations that have `tmax` recorded. The year filtering is an operation on the time axis, so we start with the long form. Whether each station has `tmax` recorded is a result of each station, rather than of each time point, hence we need to switch to the list-column form with `global()`. To calculate whether `tmax` is recorded, we mutate a column `tmax_missing` that takes `TRUE` if all the `tmax` in the nested list column `ts` are `NA` and `FALSE` otherwise. To get the stations that we want, we need another filter on `tmax_missing`.


```{r}
out <- oz_zoom %>%
  filter(year(date) == 2020) %>% 
  global() %>% 
  mutate(tmax_missing = ifelse(all(is.na(ts$tmax)), TRUE, FALSE)) %>% 
  filter(!tmax_missing)

out
```

### Example 2

Now we want to select the stations that have been registered with world meteorological organisation (WMO) and the dataset `station` has a column `wmo_id` that records this information. To do this task, we first need to join the `station` dataset with our climate dataset and then filter out those stations that don't have the WMO id. Since the join is by station rather than by time, we start with the list-column form and write the exact same syntax of join and filter as with tidyverse. 

```{r}
# join wmo_id for each station
to_join <- station %>% select(id, wmo_id)
out <- oz_global %>% 
  left_join(to_join, by = c("station" = "id")) %>% 
  filter(!is.na(wmo_id))
out
```

### Example 3

Sometimes, we would like to have station-wise and time-wise variables in the same form (i.e. when plotting glyph maps). This can also be seen as a joining task, on the long form, with the dataset to join being the metadata. `migrate()` is a verb introduced as the shortcut for `left_join()` with a cubble's metadata and below is the comparison of the two syntaxes.

```{r}
out %>% 
  zoom() %>% 
  migrate(lat, long)

out %>% 
  zoom() %>% 
  left_join(meta(out) %>% select(station, lat, long))
```

## Time series as a tsibble object

Cubble also support a tsibble data structure for time series computation. 

### Creation

A cubble can also be created from an underlying tsibble object. The resulting list-column form shows a `tbl_ts` type for each nested cell in the `ts` column and a tsibble heading in the long form.

```{r}
climate_tsibble <- climate_flat %>% tsibble::as_tsibble(index = date, key = station)
oz_global2 <- climate_tsibble %>% global(station)
oz_zoom2 <- oz_global2 %>% zoom()

oz_global2
oz_zoom2
```

### Manipulation

With a tsibble structure, we can make a monthly summary of our variables. Here is an example on calculating the monthly total precipitation and average max/min temperature in 2020. As before, we start with the long form to filter out the records that are not in 2020 and add a `ym` variable as the yearmonth representation of the date. `index_by` adds another grouping on the `ym` variable for computing the corresponding monthly summary.

```{r}
time_wise2 <- oz_zoom2 %>% 
  filter(lubridate::year(date) == 2020) %>% 
  mutate(ym = tsibble::yearmonth(date)) %>% 
  index_by(ym) %>% 
  summarise(prcp = sum(prcp, na.rm = TRUE),
            across(tmax:tmin, ~mean(.x, na.rm = TRUE)))

time_wise2
```

## Sampling and add missing summary

[add documentation on slicing]

Missing summary gives a better view of the data quality recorded in each station. 

  - `add_missing_prct()` binds `{VAR}_missing` columns to calculate the percentage of missing for  each station.
  - `add_missing_dscrb()` categories the percentage missing calculated into three categories:  almost no missing, some missing, and almost all missing. The two cutoff values can be specified for switching between categories. This categorisation is to be further used for the viz [more on this].

```{r}
oz_global2 %>% 
  add_missing_prct(prcp: tmax) %>% 
  add_missing_dscrb()
```



# Old stuff

```{r}
count_var <- function(dt){
  dt %>% 
    as_tibble() %>% 
    pivot_longer(prcp:tavg, names_to = "datatype", values_to = "value") %>% 
    group_by(datatype) %>% 
    # think of a better way to filter out those block missing
    summarise(missing = sum(value, na.rm = TRUE)) %>% 
    filter(missing != 0) %>% nrow()
}

```

* some functions to unnest into a tsibble structure, tried unnest_tsibble/ unnest
* some functions to move variables in/ out of nested list - migrate
* some functions to allow data masking within list
* reproduce old result: think about how would you plot the data with list-column structure

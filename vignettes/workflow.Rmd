---
title: "2. Data manipulation with cubble"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE, 
  warning = FALSE
)
```

```{r setup, echo = FALSE}
library(cubble)
library(tsibble)
library(lubridate)
library(dplyr)
library(ggplot2)
library(rmapshaper)
library(patchwork)
library(GGally)
```

[why you want to make a plot like this]

```{r}

```


Below are several examples on how to manipulate a cubble object with dplyr verbs:

```{r fig.height=7, fig.width=10, echo = FALSE}
state_map <- ms_simplify(ozmaps::abs_ste, keep = 5e-3)

time_wise2 <- climate_small %>% 
  stretch() %>% 
  filter(lubridate::year(date) == 2020) %>% 
  mutate(ym = tsibble::yearmonth(date)) %>% 
  index_by(ym) %>% 
  summarise(prcp = sum(prcp, na.rm = TRUE),
            across(tmax:tmin, ~mean(.x, na.rm = TRUE))) %>% 
  migrate(lat, long)

gly_dt <- glyphs(time_wise2, x_major = "long", y_major = "lat", 
                 x_minor = "ym", y_minor = "tmax", 
                 height = 1, width = 2)

plot_map(state_map) + 
  #add_ref_lines(gly_dt, color = "grey90") +
  #add_ref_boxes(gly_dt, color = "grey90") +
  ggplot2::geom_path(data = gly_dt, ggplot2::aes(gx, gy, group = gid))
```

Three tasks to do:

  - filter out some stations don't have `tmax` recorded
  - summarise the data into monthly record

### Mutate and filter

In the first example, we want to only keep the stations that have `tmax` recorded in 2020. This requires first narrow down the records to those in 2020, determine if `tmax` is missing for each station, and then retain those stations that have `tmax` recorded. The year filtering is an operation on the time axis, so we start with the long form. Whether each station has `tmax` recorded is a result of each station, rather than of each time point, hence we need to switch to the nested form with `tamp()`. To calculate whether `tmax` is recorded, we mutate a column `tmax_missing` that takes `TRUE` if all the `tmax` in the nested list column `ts` are `NA` and `FALSE` otherwise. To get the stations that we want, we need another filter on `tmax_missing`.

```{r echo = FALSE}
climate_2020 <- oz_climate %>% 
  filter(year(date) == 2020) %>% 
  tamp(station) %>% 
  mutate(tmax_missing = ifelse(all(is.na(ts$tmax)), TRUE, FALSE)) 

p1 <- plot_map(map_data = state_map) + 
  geom_point(data = climate_2020, aes(x = long, y = lat, color = tmax_missing)) 

p2 <- plot_map(map_data = state_map) + 
  geom_point(data = climate_2020 %>% filter(!tmax_missing), aes(x = long, y = lat, color = tmax_missing)) 

(p1 | p2) &
  theme(legend.position = "bottom")
```

```{r}
oz_climate %>%
  filter(year(date) == 2020) %>% 
  tamp(station) %>% 
  mutate(tmax_missing = ifelse(all(is.na(ts$tmax)), TRUE, FALSE)) %>% 
  filter(!tmax_missing)
```

### Summarise

With a tsibble structure, we can make a monthly summary of our variables. Here is an example on calculating the monthly total precipitation and average max/min temperature in 2020. As before, we start with the long form to filter out the records that are not in 2020 and add a `ym` variable as the yearmonth representation of the date. `index_by` adds another grouping on the `ym` variable for computing the corresponding monthly summary.

```{r}
time_wise2 <- climate_small %>% 
  stretch() %>% 
  filter(lubridate::year(date) == 2020) %>% 
  mutate(ym = tsibble::yearmonth(date)) %>% 
  index_by(ym) %>% 
  summarise(prcp = sum(prcp, na.rm = TRUE),
            across(tmax:tmin, ~mean(.x, na.rm = TRUE)))

time_wise2
```


### Join

Now we want to select the stations that have been registered with world meteorological organisation (WMO) and the dataset `station` has a column `wmo_id` that records this information. To do this task, we first need to join the `station` dataset with our climate dataset and then filter out those stations that don't have the WMO id. Since the join is by station rather than by time, we start with the nested form and write the exact same syntax of join and filter as with tidyverse. 

```{r echo = FALSE}
to_join <- station %>% select(id, wmo_id)
out <- climate_small %>% 
  left_join(to_join, by = c("station" = "id")) %>% 
  filter(!is.na(wmo_id))

migrated <- out %>% 
  stretch() %>% 
  migrate(lat, long) %>% 
  mutate(date = as.numeric(date))


```

```{r}
# join wmo_id for each station
to_join <- station %>% select(id, wmo_id)
out <- climate_small %>% 
  left_join(to_join, by = c("station" = "id")) %>% 
  filter(!is.na(wmo_id))
out
```

Sometimes, we would like to have station-wise and time-wise variables in the same form (i.e. when plotting glyph maps). This can also be seen as a joining task, on the long form, with the dataset to join being the metadata. `migrate()` is a verb introduced as the shortcut for `left_join()` with a cubble's metadata and below is the comparison of the two syntaxes.

```{r}
out %>% 
  stretch() %>% 
  migrate(lat, long)

out %>% 
  stretch() %>% 
  left_join(leaves(out) %>% select(station, lat, long))
```


<!-- ### Sampling and add missing summary -->

<!-- [add documentation on slicing] -->

<!-- Missing summary gives a better view of the data quality recorded in each station.  -->

<!--   - `add_missing_prct()` binds `{VAR}_missing` columns to calculate the percentage of missing for  each station. -->
<!--   - `add_missing_dscrb()` categories the percentage missing calculated into three categories:  almost no missing, some missing, and almost all missing. The two cutoff values can be specified for switching between categories. This categorisation is to be further used for the viz [more on this]. -->

<!-- ```{r} -->
<!-- climate_small %>%  -->
<!--   add_missing_prct(prcp: tmax) %>%  -->
<!--   add_missing_dscrb() -->
<!-- ``` -->




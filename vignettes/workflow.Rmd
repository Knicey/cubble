---
title: "workflow"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  message = FALSE, 
  warning = FALSE
)
```

```{r setup}
library(cubble)
library(tsibble)
library(lubridate)
library(dplyr)
```

# Create a cubble

In a nested form created by `tamp()`, the cubble has all the time-invariant variables presented and time-variant variables nested into a column called `ts`. This structure has an underlying  row-wise structure where each row constitutes a group. 

```{r}
climate_nested <- climate_flat %>% tamp(station)
climate_nested
```

On top of the attributes inherent from `tibble` (`name` and `row.names`) and `rowwise_df` (`groups`), a cubble has two additional attributes: `form` and `leaves`. `form` specifies whether the data object is a nested or long form - a nested form is more suitable for computing time-invariant measures for each group while long form is more for time-variant computation.  `leaves` stores the time-invariant information so that a cubble can be switched between the nested and long form. 

```{r}
attributes(climate_nested)
```

`stretch()` switches a cubble object into the long form where only time-variant variables are shown and  time-invariant variables are not directly shown but can be accessed through the `leaves` attributes. This avoids all the time-invariant variables being repeated for each group at each timestamp and focus on the time-wise computation. 

```{r}
climate_long <- climate_nested %>% stretch()
climate_long
```

`tamp` and `stretch` can be repeatedly used to switch between the two form and below shows switching back to the nested form from long form by `tamp()`: 

```{r}
climate_long %>% tamp()
```

# Manipulation

## Work with dplyr verbs

Below are three examples on how to manipulate a cubble object with dplyr verbs:

### Example 1 

In the first example, we want to only keep the stations that have `tmax` recorded in 2020. This requires first narrow down the records to those in 2020, determine if `tmax` is missing for each station, and then retain those stations that have `tmax` recorded. The year filtering is an operation on the time axis, so we start with the long form. Whether each station has `tmax` recorded is a result of each station, rather than of each time point, hence we need to switch to the nested form with `tamp()`. To calculate whether `tmax` is recorded, we mutate a column `tmax_missing` that takes `TRUE` if all the `tmax` in the nested list column `ts` are `NA` and `FALSE` otherwise. To get the stations that we want, we need another filter on `tmax_missing`.


```{r}
climate_long %>%
  filter(year(date) == 2020) %>% 
  tamp() %>% 
  mutate(tmax_missing = ifelse(all(is.na(ts$tmax)), TRUE, FALSE)) %>% 
  filter(!tmax_missing)


```

### Example 2

Now we want to select the stations that have been registered with world meteorological organisation (WMO) and the dataset `station` has a column `wmo_id` that records this information. To do this task, we first need to join the `station` dataset with our climate dataset and then filter out those stations that don't have the WMO id. Since the join is by station rather than by time, we start with the nested form and write the exact same syntax of join and filter as with tidyverse. 

```{r}
# join wmo_id for each station
to_join <- station %>% select(id, wmo_id)
out <- climate_small %>% 
  left_join(to_join, by = c("station" = "id")) %>% 
  filter(!is.na(wmo_id))
out
```

### Example 3

Sometimes, we would like to have station-wise and time-wise variables in the same form (i.e. when plotting glyph maps). This can also be seen as a joining task, on the long form, with the dataset to join being the metadata. `migrate()` is a verb introduced as the shortcut for `left_join()` with a cubble's metadata and below is the comparison of the two syntaxes.

```{r}
out %>% 
  stretch() %>% 
  migrate(lat, long)

out %>% 
  stretch() %>% 
  left_join(leaves(out) %>% select(station, lat, long))
```

## Time series as a tsibble object

Cubble also support a tsibble data structure for time series computation. 

### Creation

A cubble can also be created from an underlying tsibble object. The resulting nested form shows a `tbl_ts` type for each nested cell in the `ts` column and a tsibble heading in the long form.

```{r}
# climate_tsibble <- climate_flat %>% tsibble::as_tsibble(index = date, key = station)
# oz_global2 <- climate_tsibble %>% global(station)
# oz_zoom2 <- oz_global2 %>% zoom()
# 
# oz_global2
# oz_zoom2
```

### Manipulation

With a tsibble structure, we can make a monthly summary of our variables. Here is an example on calculating the monthly total precipitation and average max/min temperature in 2020. As before, we start with the long form to filter out the records that are not in 2020 and add a `ym` variable as the yearmonth representation of the date. `index_by` adds another grouping on the `ym` variable for computing the corresponding monthly summary.

```{r}
time_wise2 <- climate_small %>% 
  stretch() %>% 
  filter(lubridate::year(date) == 2020) %>% 
  mutate(ym = tsibble::yearmonth(date)) %>% 
  index_by(ym) %>% 
  summarise(prcp = sum(prcp, na.rm = TRUE),
            across(tmax:tmin, ~mean(.x, na.rm = TRUE)))

time_wise2
```

## Sampling and add missing summary

[add documentation on slicing]

Missing summary gives a better view of the data quality recorded in each station. 

  - `add_missing_prct()` binds `{VAR}_missing` columns to calculate the percentage of missing for  each station.
  - `add_missing_dscrb()` categories the percentage missing calculated into three categories:  almost no missing, some missing, and almost all missing. The two cutoff values can be specified for switching between categories. This categorisation is to be further used for the viz [more on this].

```{r}
climate_small %>% 
  add_missing_prct(prcp: tmax) %>% 
  add_missing_dscrb()
```




---
title: "4. Matching different data sources"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{matching}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE,
  message = FALSE,
  out.width = "100%"
)
library(cubble)
library(dplyr)
library(ggplot2)
library(patchwork)
```

One common type of task with spatio-temporal data is to match nearby sites. For example, we may want to verify the location of an old list of stations with current stations, or we may want to match the data from different data sources. This vignette introduces the spatial and temporal matching in cubble with an example on matching river level data with precipitation in Victoria, Australia.


In cubble, data can be matched spatially or temporarily with `match_spatial()` and `match_temporal()`. The function `match_spatial()` calculates the spatial distance between observations in two cubbles. Different distances are available with projected or unprojected coordinate reference system. Analysts can subset the number of matched group to output with argument `spatial_n_group` (by default 4 groups) and the number of match per group with argument `spatial_n_group` (by default 1, that is, one-to-one matching). The syntax to use `match_spatial()` is
  
````
match_spatial(<cubble_obj1>, <cubble_obj2>, ...)
````

The function `match_temporal()` calculates the time series similarity between spatially matched groups. Two identifiers needs to be specified on the variable separates the each matched group (`match_id`) and the variable separates the two sources (`data_id`). The argument `temporal_by` uses the `by` syntax from dplyr `*_join` to specify the temporal matching variable. 
  
  The similarity score between two time series in the spatially matched group is calculated by a matching function, which analysts can customise. The matching function should take two time series in a list and output a single numerical score, which allows for interfacing with existing time series distance calculation implementation. By default, cubble implements a simple peak matching algorithm (`match_peak`) that counts the number of peaks in two time series that fall within a specified temporal window. The syntax to use `match_temporal()` is
  
````
match_temporal(
  <cubble_obj_from_match_spatial>, 
  data_id = , match_id = , 
  temporal_by = c("..." = "...")
)
````

# Spatial matching

Bureau of Meteorology collects [water data](http://www.bom.gov.au/metadata/catalogue/19115/ANZCW0503900528?template=full) from river gauges and this includes variables: electrical conductivity, turbidity, water course discharge, water course level, and water temperature. In particular, water level will interactive with precipitation from the climate data since rainfall will raise the water level in the river. Here is the location of available weather station and water gauges in Victoria:

```{r echo = FALSE}
river <- cubble::river %>%  mutate(type = "river") %>% rename(id = station)

climate_vic <- climate_aus %>%  
  # subset for Victoria stations
  filter(between(as.numeric(stringr::str_sub(id, 7, 8)), 76, 90)) %>%  
  mutate(type = "climate")

vic_map <- ozmaps::abs_ste %>%  filter(NAME == "Victoria")

ggplot() + 
  geom_sf(data = vic_map) + 
  geom_point(data = dplyr::bind_rows(river, climate_vic), 
             aes(x = long, y = lat, color = type)) + 
  theme_bw() +
  theme(legend.position = "bottom") +
  labs(x = "Longitude", y = "Latitude") + 
  scale_color_brewer(palette = "Dark2")
```

Both `climate_vic` and `river` are cubble objects and we can get a summary of the 10 closest pairs:

```{r}
(res_sp <- match_spatial(climate_vic, river, spatial_n_group = 10))
```

The result can also be returned as cubble objects with argument `return_cubble = TRUE`. The output is a list where each element is a paired cubble object and you may consider combining all the results into a single cubble with `bind_rows()`. Care needs to be taken on in the case when a site is close to two stations since by construction, cubble require unique rows in the nested form. From the summary table above, river station `226027` is matched to more than one weather station: `ASN00085072` (group 3) and `ASN00085298` (group 5). (Similarly river station `230200` is matched in group 7 and 8). One can either deselect one pair before binding the results, or take the list and work with the `purrr::map` syntax:

```{r}
res_sp <- match_spatial(climate_vic, river, spatial_n_group = 10, return_cubble = TRUE)
str(res_sp, max.level = 0)
res_sp[[1]]
(res_sp <- res_sp[-c(5, 8)] %>% bind_rows())
```


# Temporal matching

For temporal matching, the variable water level (`Water_course_level`) from the river data will be matched to precipitation (`prcp`) in the weather station data. The variable identifying each matched group is `group` and the variable identifying the two datasets is `type`:

```{r}
(res_tm <- res_sp %>% 
  match_temporal(
    data_id = type, match_id = group,
    temporal_by = c("prcp" = "Water_course_level")))
```

Similarly, the cubble output can be returned with the argument `return_cubble = TRUE`. Here we select the four pairs with the highest number of matching peaks:

```{r}
res_tm <- res_sp %>% 
  match_temporal(
    data_id = type, match_id = group,
    temporal_by = c("prcp" = "Water_course_level"),
    return_cubble = TRUE)
(res_tm <- res_tm %>% bind_rows() %>% filter(group %in% c(1, 7, 6, 9)))
```

And then we can visialise them in space or across time: 

```{r echo = FALSE}
res_tm_long <- res_tm %>%  
  face_temporal() %>%  
  unfold(group, type) %>%  
  group_by(group, type) %>%
  mutate(matched = (matched - min(matched, na.rm = TRUE))/ (max(matched, na.rm = TRUE) - min(matched, na.rm = TRUE))) 

vic_map <- ozmaps::abs_ste |> 
  filter(NAME == "Victoria") |> 
  rmapshaper::ms_simplify()  

p1 <-ggplot() + 
  geom_sf(data = vic_map, fill = "grey95", color = "white") + 
  geom_point(data = dplyr::bind_rows(river, climate_vic), 
             aes(x = long, y = lat, color = type), 
             alpha = 0.2, fill = 0.2) +
  geom_point(data = res_tm %>% as_tibble(), 
             aes(x = long, y = lat, color = type)) +
  ggrepel::geom_label_repel(
    data = res_tm %>%  filter(type == "climate") %>% as_tibble(), 
    aes(x = long, y = lat, label = group)) +
  scale_color_brewer(palette = "Dark2")  + 
  ggthemes::theme_map() +
  ggplot2::theme(legend.position = "bottom") +
  ggplot2::labs(x = "Longitude", y = "Latitude") 

p2 <- res_tm_long %>%  
  ggplot(aes(x = date, y = matched, group = type,color = type)) + 
  geom_line() + 
  facet_wrap(vars(group)) + 
  scale_color_brewer(palette = "Dark2", guide = "none") + 
  theme_bw() + 
  labs(x=  "date") + 
  scale_x_date(date_labels = "%b") + 
  labs(x = "Week", y = "Precipitation/ water level")

(p1 | p2) + 
  patchwork::plot_layout(guides = "collect") + 
  plot_annotation(tag_levels = 'a')&
  theme(legend.position = "bottom") 
```

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/matching.R
\name{match_sites}
\alias{match_sites}
\alias{match_spatial}
\alias{match_temporal}
\title{Matching sites from two data sources}
\usage{
match_sites(
  df1,
  df2,
  crs = sf::st_crs("OGC:CRS84"),
  which = NULL,
  par = 0,
  spatial_n_each = 1,
  spatial_n_group = 4,
  temporal_matching = TRUE,
  temporal_by,
  temporal_match_fn = match_peak,
  temporal_n_highest = 20,
  temporal_window = 5,
  temporal_min_match = 10,
  ...
)

match_spatial(
  df1,
  df2,
  crs = sf::st_crs("OGC:CRS84"),
  which = NULL,
  par = 0,
  spatial_n_each = 1,
  spatial_n_group = 4,
  return_cubble = FALSE
)

match_temporal(
  data,
  data_id,
  match_id,
  temporal_by,
  return_cubble = FALSE,
  temporal_match_fn = match_peak,
  temporal_n_highest = 20,
  temporal_window = 5,
  temporal_min_match = 10,
  ...
)
}
\arguments{
\item{df1, df2}{the two cubble objects to match}

\item{crs}{a crs object from \code{st_crs}}

\item{which}{character; for Cartesian coordinates only: one of \code{Euclidean}, \code{Hausdorff} or \code{Frechet}; for geodetic coordinates, great circle distances are computed; see details}

\item{par}{for \code{which} equal to \code{Hausdorff} or \code{Frechet}, optionally use a value between 0 and 1 to densify the geometry}

\item{spatial_n_each}{integer, the number of matched "station" in \code{df2} for each \code{df1} record}

\item{spatial_n_group}{integer, the number of matched group (pair) return}

\item{temporal_matching}{logical, whether to match temporally}

\item{temporal_by}{in the syntax of c("xxx" = "xxx), the variables to match in \code{df1} and \code{df2}}

\item{temporal_match_fn}{character, the function name on how two time series should be matched}

\item{temporal_n_highest}{numeric, the number of highest peak used for temporal matching in \code{match_peak}}

\item{temporal_window}{The temporal window allowed in \code{match_peak}}

\item{temporal_min_match}{The minimum number of peak matching for temporal matching in \code{match_peak}}

\item{...}{parameters passing to temporal match}

\item{return_cubble}{logical (default to false), whether to return the cubble object or a matching summary table}

\item{data}{the result from spatial matching}

\item{data_id}{variable name that separates \code{df1} and \code{df2}}

\item{match_id}{variable name that groups the same match}
}
\description{
The function includes both spatial and temporal matching. The spatial matching
is based on the distance and the distance is calculated using the Vincenty
formula assuming earth is sphere with a radius of 6371 km. The temporal matching
first filters out the \code{n} largest increases, determined by \code{temporal_n_highest},
in both datasets,  constructs an interval of length \code{temporal_window} from
one dataset and count the number that large increase from the other dataset
falls into the interval constructed.
}
\examples{
a1 <- match_spatial(climate_aus, river)
# turn with different distance calculation:
a2 <- match_spatial(climate_aus, river, which = "Hausdorff")
# tune the number of matches in each group
a3 <- match_spatial(climate_aus, river, spatial_n_each = 5, spatial_n_group = 2)
}
